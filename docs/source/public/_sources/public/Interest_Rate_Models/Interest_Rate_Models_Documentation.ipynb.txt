{
 "cells": [
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Interest Rate Models"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Available models"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* **Vasicek**,\n",
    "* **Hull-White**,\n",
    "* **G2++**.\n",
    "\n",
    "See Chapter 3 and 4 of Brigo and Mercurio (BM) *Interest Rate Models - Theory and Practice* for details."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Available classes and methods"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## generate_paths"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "It returns the stochastic variable needed for the computation of the future bond, see [next section](##compute_future_bond). More precisely, in general, \n",
    "$$\n",
    "r(t)=\\varphi(t)+\\sum_{l=0}^{L} x^l(t)\\,,\n",
    "$$ \n",
    "for bond pricing we will be interested in $\\underline{x}=(x^l)_{l=0}^L$. The term $\\varphi(t)$ is introduced to recover the initial spot curve $T\\to P^M(0, T) \\text{ for }T>0$ , so if the model cannot do this, automatically $\\varphi\\equiv 0$. In particular,\n",
    "\n",
    "* **Vasicek**: $r(t)$ , see (3.9) of BM,\n",
    "* **Hull-White**: $x(t)$ , see page 75 of BM,\n",
    "* **G2++**: $(x(t), y(t))$ , see Lemma 4.2.2 of BM.\n",
    "\n",
    "Let us call this $\\underline{x}=(x^l)_{l=0}^L$. More specifically, it returns a four-dimensional array of the form:\n",
    "\n",
    "$$\n",
    "    \\left(x_{i}^l(t^0_k,t^1_{j-1})\\right)_{i,j\\in\\{0, \\ldots, J+1\\},k,l}\\,,\n",
    "$$\n",
    "\n",
    "for the $i$-th simulation of the $k$-th start date, $t^0_k$ and $l$-th component evaluated at the time corresponding to the $j$-th step date, $t^1_j$ , ($j=-1$ corresponds to the starting date, see intervals below). Note that for a given valuation date (fixed $k$) we have $t^1_{j=-1, k} := t^0_k$, which is consistent with the definition of `intervals` given below.\n",
    "\n",
    "**Remark:** following Python conventions, in the whole document we will use the so-called zero-based indexing, i.e., $\\underline{x}=(x^l)_{l=0}^L$ instead of $\\underline{x}=(x^l)_{l=1}^{L+1}$.\n",
    "\n"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "$\\text{Code}$ - math $(\\TeX)$ **translation**"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* start_dates      $\\rightarrow \\{t^0_k\\}_{k=0}^K$ ,\n",
    "* step_dates        $\\rightarrow \\{t^1_j\\}_{j=0}^J$ , \n",
    "* short_rate_draws  $\\rightarrow$ a 4 dimensional array with the draws for the simulation following the standard conventions for the indexes $(i,j,k,l)$ , \n",
    "* intervals $\\rightarrow \\textrm{intervals}[j,k]=\\tau(t^1_{j-1}, t^1_{j})$ for $j>0$ and  $\\textrm{intervals}[0,k]=\\tau(t^0_{k}, t^1_{0})$. $\\tau$ represents the day count convention, see page 5 of Chapter 1 of Brigo and Mercurio, and will depend on the calendar used. For simplicity, we can think of it as $\\tau(t,t')=t'-t$ as a year fraction."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## generate_short_rate"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Similar as above, it returns $r(t)$ according to the specified model. More specifically, it returns a four-dimensional array of the form:\n",
    "\n",
    "$$\n",
    "    \\left(r_{i}(t^0_k,t^1_j)\\right)_{i,j,k,l=0}\\,,\n",
    "$$\n",
    "\n",
    "for the $i$-th simulation of the $k$-th start date at the time corresponding to the $j$-th step date ($j=0$ correspond to the starting date)."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "$\\text{Code}$ - math $(\\TeX)$ **translation**"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* start_dates      $\\rightarrow \\{t^0_k\\}_{k=0}^K$ ,\n",
    "* step_dates        $\\rightarrow \\{t^1_j\\}_{j=0}^J$ , \n",
    "* short_rate_draws  $\\rightarrow$ a 4 dimensional array with the draws for the simulation following the standard conventions for the indexes $i,j,k,l$ , \n",
    "* intervals $\\rightarrow \\textrm{intervals}$ \n",
    "$$\n",
    "\\textrm{intervals}[j,k]= \\begin{cases}\\textrm{intervals}[j,k]=\\tau(t^1_{j-1}, t^1_{j})\\text{ for }j>0 \\text{ (independent of } k\\text{)}\\,,\\\\\n",
    "\\textrm{intervals}[0,k]=\\tau(t^0_{k}, t^1_{0})\\text{ for }j=0\\,.\n",
    "\\end{cases}\n",
    "$$\n",
    "\n",
    "$\\tau$ represents the day count convention, see Chapter 1 of Brigo and Mercurio, and will depend on the calendar used. For simplicity, we can think of it as $\\tau(t,t')=t'-t$ as a year fraction."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## compute_future_bond"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "For the dates $\\{t^0_k\\}_{k=0}^K$ ,  $\\{t^1_j\\}_{j=0}^{J}$ , $\\{t^2_j\\}_{j=0}^{J'}$ it computes\n",
    "\n",
    "$$\n",
    "P_{t^0}\\left(t^1, t^2\\right)\n",
    "$$\n",
    "\n",
    "according to the specified model. The subscript of $P$ , $t^0$ , represents the time considered as origin for \"calibration\", $P_{t^0}(t^0,T)=P^M(t^0,T)$ , market data. As we saw in [the previous section](##generate_paths), this will only be the case for some models. For those models in which the spot curve is not recovered, once the parameters are fixed, $t_0$ is irrelevant.\n",
    "\n",
    "More precisely, it returns the array:\n",
    "\n",
    "$$\n",
    "     \\left(P_{t^0_k}\\left(t^1_j, t^2_j, \\underline{x}_i\\left(t^0_k, t^1_j\\right) \\right)\\right)_{i,j,k, l=0}\\,,\n",
    "$$\n",
    "\n",
    "where $P_{t^0}\\left(t^1, t^2, \\underline{x}(t^0, t^1)\\right)$ makes explicit that the bond price depends on the stochastic factors of the model, $\\underline{x}$ , e.g., $\\underline{x}=(x,y)$ for G2++.\n",
    "\n",
    "Obviously, it is assumed that\n",
    "\\begin{equation} \\tag{1}\n",
    "t^0_k \\le t^1_j\\le t^2_j \\qquad \\forall j,k\\,.\n",
    "\\end{equation}\n",
    "The following broadcasting rule must be satisfied,\n",
    "\n",
    "$$\n",
    "\\text{either }\\quad J=J' \\quad\\text{ or }\\quad \\min\\{J+1,J'+1\\}=1\\,,\n",
    "$$\n",
    "\n",
    "and, in the returned array, $j\\in \\{0,\\ldots, \\max(J, J')\\}$. Recall that we are using a zero-based numbering, so $J+1$ is the cardinality of the set of $\\{j\\}_{j\\in\\mathcal{J}}=\\{0,1,\\ldots, J\\}$.\n",
    "\n",
    "**Remark:** If $\\{t^0_k\\}_{k=0}^K=\\{t^1_j\\}_{j=0}^{J}$ as increasing in time sequences, then (1) is not assumed, as this will be useful for compute_spot_bond. But in that case note that only the elements below the diagonal ($j\\ge k$ for a given $i$) of\n",
    "$$\n",
    "     \\left(P_{t^0_k}\\left(t^1_j, t^2_j, \\underline{x}_i\\left(t^0_k, t^1_j\\right) \\right)\\right)_{i,j,k,l=0}\\,,\n",
    "$$\n",
    "make sense."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "$\\text{Code}$ - math $(\\TeX)$ **translation**"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* dates      $\\rightarrow \\{t^0_k\\}_{k=0}^K$ ,\n",
    "* beg_dates        $\\rightarrow \\{t^1_j\\}_{j=0}^J$ , \n",
    "* end_dates          $\\rightarrow \\{t^2_j\\}_{j=0}^J$ , \n",
    "* calendar        $\\rightarrow$ calendar for computations,\n",
    "* srsim $\\rightarrow$ simulations, i.e., srsim[i, j, k, l] = $x^l_i(t^0_k, t^1_j)$ being the latter the $i$-th simulation at time $t^1_j$ , with origin $t^0_k$ for the $l$-th stochastic component."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## compute_spot_bond"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "For the dates  $\\{t^1_j\\}_{j=0}^J$ , $\\{t^2_j\\}_{j=0}^{J'}$ it computes\n",
    "\n",
    "$$\n",
    "P_{t^1}\\left(t^1, t^2\\right)\n",
    "$$\n",
    "\n",
    "according to the specified model. More precisely, it returns the array:\n",
    "\n",
    "$$\n",
    "     \\left(P_{t^1_j}\\left(t^1_j, t^2_j\\right)\\right)_{j}\\,,\n",
    "$$\n",
    "Clearly, it is independent of the simulation as it only depends on the initial curve. This is the spot curve if we recover it using $\\varphi$, as in G2++ and Hull-White, see above. Another way to see the simulation independence uses the previous method compute_future_bond and the notation\n",
    "$P_{t^1}\\left(t^1, t^2, \\underline{x}(t^1,t^1)\\right)$ (it makes explicit that the bond price depends on the stochastic factors of the model, $\\underline{x}$). Here, the simulations are $\\underline{x}(t^1, t^1)$, i.e., it is always the initial condition, so it is independent of the simulation. \n",
    "The following broadcasting rule must be satisfied,\n",
    "\n",
    "$$\n",
    "\\text{either }\\quad J=J' \\quad\\text{ or }\\quad \\min\\{J+1,J'+1\\}=1\\,,\n",
    "$$\n",
    "\n",
    "and, in the returned array, $j\\in \\{1,\\ldots, \\max(J, J')\\}$. Recall that we are using a zero-based numbering, so if $J+1$ is the cardinality of the set of $\\{j\\}_{j\\in\\mathcal{J}}=\\{0,1,\\ldots, J\\}$."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "$\\text{Code}$ - math $(\\TeX)$ **translation**"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* beg_dates        $\\rightarrow \\{t^1_j\\}_{j=0}^J$ , \n",
    "* end_dates          $\\rightarrow \\{t^2_j\\}_{j=0}^{J'}$ , \n",
    "* calendar        $\\rightarrow$ calendar for computations."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## compute_forward_bond_old"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "For the dates $t^0$ ,  $\\{\\tau_j\\}_{j=0}^J$ , $\\{\\tau_{j'}^f\\}_{j'=1}^{J'}$ it computes\n",
    "$$\n",
    "\\text{FP}_{t^0}\\left(t_1,\\tau_j,\\tau^f_{j'}\\right):=\\frac{P_{t^0}\\left(t_1, \\tau_{j'}^f\\right)}{P_{t^0}\\left(t_1,\\tau_j\\right)}\n",
    "$$\n",
    "according to the specified model and defining $t^1:=\\tau_0$. It is assumed that $t^0 <t^1$. The subscript of $P$ represents the time considered as origin for calibration, as in [the previous section](##compute_future_bond). The following broadcasting rule must be satisfied,\n",
    "$$\n",
    "\\text{either }\\quad J=J' \\quad\\text{ or }\\quad \\min\\{J,J'\\}=1\\,.\n",
    "$$\n",
    "\n",
    "With this, we can more precisely say that it returns the array:\n",
    "\n",
    "$$\n",
    "\\left(\\text{FP}_{t^0}\\left(t_1, \\tau_{j}, \\tau_{{j}}^f, \\underline{x}_i(t_0, t_1)\\right)\\right)_{i=0,\\, {j}=1}^{i=I,\\, j=\\max{J, J'}}\\,,\n",
    "$$\n",
    "\n",
    "being $I+1$ the number of simulations and using the same notation as above. Note that if $J=1$ , $\\tau_{j}:=\\tau_1\\, \\forall j$ (analogously for $\\tau^f$), this is the standard numpy broadcasting. \n"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "$\\text{Code}$ - math $(\\TeX)$ **translation**"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "- date $\\rightarrow t^0$ ,\n",
    "- step_dates $\\rightarrow(\\tau_j)_{j=0}\\,,\\, t_1:=\\tau_0$ , .\n",
    "- final_date $\\rightarrow \\{\\tau_{j'}^f\\}_{j'=1}^{J'}$.\n",
    "- calendar $\\rightarrow$ calendar\n",
    "- srsim $\\rightarrow$ simulations, i.e., srsim[i, 0, 0, l] = $x^l_i(t^0, t^1)$ being the latter the $i$-th simulation for the $l$-th stochastic factor at time $t^1$ and with origin $t^0$ , see above."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## compute_forward_bond"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "For the dates $\\{t^0_k\\}_{k=0}^K$ ,  $\\{t^1_j\\}_{j=0}^J$ , $\\{T_l\\}_{l=0}^{L}$ it computes\n",
    "$$\n",
    "\\text{FP}_{t^0}\\left(t^1,T_{l-1}, T_l\\right):=\\frac{P_{t^0}\\left(t^1, T_l\\right)}{P_{t^0}\\left(t_1,T_{l-1}\\right)}\n",
    "$$\n",
    "according to the specified model and defining $T_{-1}:=t_1$ , so the denominator equals one if $l=0$. The subscript of $P$ represents the time considered as origin for calibration, as in [the previous section](##compute_future_bond). It is assumed that \n",
    "$$\n",
    "t^0_k \\le t^1_j\\quad\\forall j,k\\,.\n",
    "$$\n",
    "With this, we can more precisely say that it returns the array $\\textrm{forwards}$ such that\n",
    "$$\n",
    "\\textrm{FP}[i,j,k,l]=\\begin{cases}\n",
    "\\text{FP}_{t^0_k}\\left(t^1_j,t^1_j, T_0, \\underline{x}_i\\left(t^0_k, t^1_j\\right)\\right)={P}_{t^0_k}\\left(t^1_j, T_0, \\underline{x}\\left(t^0_k, t^1_j\\right)\\right)&\\text{ if } l=0\\,,\\\\ \n",
    "\\text{FP}_{t^0_k}\\left(t^1_j,T_{l-1}, T_l, \\underline{x}_i\\left(t^0_k, t^1_j\\right)\\right)&\\text{ otherwise}\\,,\n",
    "\\end{cases}\n",
    "$$\n",
    "\n",
    "being $I+1$ the number of simulations and making explicit that $P$ depends on the stochastic factors of the model, same notation as above.\n",
    "\n",
    "***WATCH OUT:*** We are following BM definition, see page XXXVI. But, to calculate a forward we need $\\text{FP}^{-1}$, i.e.,\n",
    "\n",
    "$$\n",
    "F(t; T, S) = \\frac{1}{S-T}\\left(\\text{FP}^{-1}(t; T, S)-1\\right)\\,,\n",
    "$$\n",
    "for $t\\le T\\le S$.\n"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "$\\text{Code}$ - math $(\\TeX)$ **translation**"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "- dates $\\rightarrow \\{t^0_k\\}_{k=0}^K$ ,\n",
    "- beg_dates $\\rightarrow\\{t^1_j\\}_{j=0}^J$ , \n",
    "- tenor_dates $\\rightarrow \\{T_l\\}_{l=0}^{L}$ ,\n",
    "- calendar $\\rightarrow$ calendar,\n",
    "- srsim $\\rightarrow$ simulations, i.e., srsim[i, j, k, n] = $x^n_i(t^0_k, t^1_j)$ being the latter the $i$-th simulation for the $n$-th stochastic factor at time $t^1_j$ and with origin $t^0_k$ , see above. Note that $l$ is now reserved for the tenor structure, not the stochastic factors."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "base",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.16"
  },
  "vscode": {
   "interpreter": {
    "hash": "ad2bdc8ecc057115af97d19610ffacc2b4e99fae6737bb82f5d7fb13d2f2c186"
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
