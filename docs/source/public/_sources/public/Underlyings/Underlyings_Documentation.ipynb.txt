{
 "cells": [
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Underlying"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# NormalAsset"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## _generate_base"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Returns the underlying following a standard  Brownian motion. For each simulation and for each valuation date we have $S(t)$. That is to say, for the $i$-th simulation and the $k$-th valuation date we have:\n",
    "\n",
    "$$\n",
    "\\textrm{base}[i, j, k] = \\Delta Y_{i,k}(t^1_{j-1,k}), \\quad j\\in\\{0, \\ldots, J+1\\},\n",
    "$$\n",
    "where \n",
    "$$\n",
    "t^1_{j-1,k}:= \\begin{cases} t^1_{j} \\qquad \\text{ for }j\\geq 0 \\quad \\text{ (independent of } k\\text{)}\\,,\\\\\n",
    "t^0_{k} \\qquad \\text{ for }j=-1\\,,\n",
    "\\end{cases}\n",
    "$$\n",
    "which is consistent with the definition of `intervals` given below. The simulation depends on the starting date as, for instance, \n",
    "$$\n",
    "Y_{i,k}(t^1_{0-1,k}) = Y_{i,k}(t^0_{k}) = Y(t_k^0)\\,,\n",
    "$$\n",
    "which is a common value for all simulations for that valuation date. "
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Technical note"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "For the sake of educational purposes, let us give a full-detailed description of the actual implementation of this part, with a full vectorization is as follows (no loop needed).Firstly, an adjustment is necessary to account for the expected impact of dividends in the pricing model. \n",
    "\n",
    "-If `forward_measure = True`, then, $\\mu=-d$ and,\n",
    "\n",
    "-If `forward_measure = False`, $\\mu=\\text{{self.drift}}-d$, where the pre-defined drift value, `self.drift`, must also be taken into account.\n",
    "\n",
    "\n",
    "Let's assume that  $S_t$ follows a standard geometric Brownian motion, i.e.,\n",
    "$$\n",
    "dS_t = \\mu S_t dt + \\sigma S_t dW_t\\,.\n",
    "$$\n",
    "Let $Y := \\log(S)$, so $Y$ follows a normal distribution. Using the Itô rule,\n",
    "$$\n",
    "dY_t =  \\left(\\mu -\\frac12 \\sigma^2\\right) dt + \\sigma d W_t \\,,\n",
    "$$\n",
    "which can be easily integrated between $s$ and $t$. \n",
    "$$\n",
    "Y_t - Y_s = \\left(\\mu -\\frac12 \\sigma^2\\right)  (t-s) + \\sigma Z\\sqrt{t-s} \\,,\n",
    "$$\n",
    "with $Z\\sim\\mathcal{N}(0,1).$ Then the `base[i,j,k]` of the Normal Asset $Y_t$  is given by\n",
    "$$\n",
    "\\Delta_j{Y}^{i,k} := {Y}^{i,k}(t^1_{j})-{Y}^{i,k}(t^1_{j-1}) = \\left(\\mu_k -\\frac12 \\sigma_k^2\\right) \\textrm{intervals}_{jk} + \\sigma_k \\cdot \\textrm{draws}_{ijk} \\cdot \\sqrt{\\textrm{intervals}_{jk}}\\,,\n",
    "$$\n",
    "where \n",
    "$$\n",
    "\\textrm{intervals}[j,k]= \\begin{cases}\\textrm{intervals}[j,k]=\\text{DCC}(t^1_{j-1}, t^1_{j})\\text{ for }j>0 \\text{ (independent of } k\\text{)}\\,,\\\\\n",
    "\\textrm{intervals}[0,k]=\\text{DCC}(t^0_{k}, t^1_{0})\\text{ for }j=0\\,.\n",
    "\\end{cases}\n",
    "$$\n",
    "$\\text{DCC}$ represents the day count convention, see [Brigo & Mercurio, 2006], and will depend on the calendar used. For simplicity, we can think of it as $\\text{DCC}(t,t')=t'-t$ as a year fraction. Also, \n",
    "\n",
    "- `draws[i,j,k]` is a sample of a random variable for the $i$-th simulation and the $k$-th valuation date for the $j$-th step (simulation date)."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " $\\text{Code}$ - math $(\\TeX)$ **translation**"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* `start_dates`      $\\rightarrow \\{t^0_k\\}_{k=0}^K$ ,\n",
    "* `step_dates`      $\\rightarrow \\{t^1_j\\}_{j=0}^J$ ,\n",
    "* `draws`    $\\rightarrow$     normal draws as above,\n",
    "* `intervals` $\\rightarrow$ intervals as above,\n",
    "* `forward_measure` $\\rightarrow$ use of the forward measure as explained above (`forward_measure = True` by default)."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## generate_paths"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "It returns the simulation paths for the asset price. For the $i$-th simulation and the $k$-th valuation date if we denote by `paths` the output of this method we have\n",
    "$$\n",
    "\\textrm{paths}[i,j,k] = Y_{i,k}(t^1_{j-1,k}), \\quad j\\in\\{0, \\ldots, J+1\\},\n",
    "$$ \n",
    "where \n",
    "$$\n",
    "t^1_{j-1,k}:= \\begin{cases} t^1_{j} \\qquad \\text{ for }j\\geq 0 \\quad \\text{ (independent of } k\\text{)}\\,,\\\\\n",
    "t^0_{k} \\qquad \\text{ for }j=-1\\,,\n",
    "\\end{cases}\n",
    "$$\n",
    "which is consistent with the definition of `intervals` given above. The simulation depends on the starting date as, for instance, \n",
    "$$\n",
    "Y_{i,k}^l(t^1_{0-1,k}) = Y_{i,k}^l(t^0_{k}) = Y^l(t_k^0)\\,,\n",
    "$$\n",
    "which is a common value for all simulations for that valuation date, the initial condition that would be obtained using market data. Similarly, parameters can depend on the simulation date."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " $\\text{Code}$ - math $(\\TeX)$ **translation**"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* `start_dates`      $\\rightarrow \\{t^0_k\\}_{k=0}^K$ ,\n",
    "* `step_dates`      $\\rightarrow \\{t^1_j\\}_{j=0}^J$ ,\n",
    "* `draws`    $\\rightarrow$     normal draws as above,\n",
    "* `intervals` $\\rightarrow$ intervals as above,\n",
    "* `forward_measure` $\\rightarrow$ use of the forward measure as explained above (`forward_measure = True` by default)."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# LogNormalAsset"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## _generate_prices"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Applies the log of the Normal Asset method. For the conventions and details on the prices  see the \"Technical note\" in the [NormalAsset section](#NormalAsset)."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## generate_paths"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Applies the exponential of the Normal Asset method. For the conventions and details on the paths  see the \"Technical note\" in the [NormalAsset section](#NormalAsset)."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Technical note"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let us give a full-detailed description of the actual implementation of this part. In this case, as explained above, $Y_t= \\log(S_t)$, then the path of the LogNormal Asset $S_t$ is defined as, \n",
    "$$\n",
    "S_t = e^{Y_t}= e^{Y_0+ \\sum_{i=1}^t \\Delta Y_i} = e^{\\log(S_0)+ \\sum_{i=1}^t \\Delta Y_i}= S_0 e^{\\sum_{i=1}^t \\Delta Y_i}\n",
    "$$\n",
    "where each $Y_i$ follows a normal distribution. "
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# VolModel"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Parent class."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## compute_implied_vol"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "For a given set of option prices, it returns the implied volatility according to the specified Black ('lognormal') or Bachelier's formula ('normal')."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Heston"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "A class for simulating the Heston stochastic volatility model using Andersen's Quadratic Exponential (QE) method.\n",
    "\n",
    "The Heston model is a widely used model for the dynamics of asset prices and their volatilities. The QE method is an efficient discretization scheme for\n",
    "simulating the Heston model, particularly for cases with high mean reversion and low volatility of volatility.\n",
    "\n",
    "We will follow the notation used in [Andersen, 2008]."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## option_price_functions"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Return European option prices (Call/Put) using the Fast Fourier Transform (FFT) algorithm based on Lewis expression [Lewis, 2000]. We use the library pyfeng. The output for a Call option is\n",
    "\n",
    "\\begin{equation*}\n",
    "\\textrm{prices}[i,j] = C(\\vec{\\theta},K_i,T_j)\n",
    "\\end{equation*}\n",
    "where $C(\\vec{\\theta},K_i,T_j)$ is the price of the Call option (the same holds for a put option)."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " $\\text{Code}$ - math $(\\TeX)$ **translation**"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* `params`      $\\rightarrow$  $\\vec{\\theta} = (\\kappa, \\epsilon, \\theta, \\rho, v_0)$ [Andersen, 2008] parameters of the model,\n",
    "* `strikes`    $\\rightarrow$  $\\{K_i\\}_i$   strikes of the options,\n",
    "* `times_exp` $\\rightarrow$ $\\{T_j\\}_j$ times to expiry of the options (in years)."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## fit_to_options"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Adjust parameters to option prices. The objective function is:\n",
    "$$\n",
    "F(\\vec{\\theta}) = \\sum_{i=1}^N (C(\\vec{\\theta}; K_i, T_i)-\\tilde{C}(K_i, T_i))^2\n",
    "$$\n",
    "where $\\tilde{C}(K_i, T_i)$ is the market price of a call option (same for put) at $t$, $N$ is the number of options used for calibration, $\\{K_i\\}_i$   strikes of the options and $\\{T_j\\}_j$ times to expiry of the options (in years). **We CAN AlSO divide by the vega due to the reasons explain in page 704 of Vol. III in [Andersen & Piterbarg].**"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " $\\text{Code}$ - math $(\\TeX)$ **translation**"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* `date`      $\\rightarrow$ valuation date $t$,\n",
    "* `options_df`      $\\rightarrow$ dataframe defining $\\tilde{C}(K_i, T_i)$. The columns are the times to expiry (in years) $\\{T_j\\}_j$ and the index the strikes $\\{K_i\\}_i$,\n",
    "* `kind`    $\\rightarrow$ $\\text{call}$ ($\\tilde{C}(K_i, T_i)$) or $\\text{put}$ ($\\tilde{P}(K_i, T_i)$),\n",
    "* `recal` $\\rightarrow$ if `recal = True` stochastic optimization is used for obtaining an initial guess for `optimize.minimize`."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## generate_paths_vol"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Returns the variance in the Heston model using Andersen's Quadratic Exponential (QE) method. For each simulation and for each valuation date we have $V(t)$ as described in [Andersen, 2008]. That is to say, for the $i$-th simulation and the $k$-th valuation date we have:\n",
    "\n",
    "$$\n",
    "\\textrm{vt}[i, j, k, l=0] = \\hat{V}_{i,k}(t^1_{j-1,k}), \\quad j\\in\\{0, \\ldots, J+1\\},\n",
    "$$\n",
    "where \n",
    "$$\n",
    "t^1_{j-1,k}:= \\begin{cases} t^1_{j} \\qquad \\text{ for }j\\geq 0 \\quad \\text{ (independent of } k\\text{)}\\,,\\\\\n",
    "t^0_{k} \\qquad \\text{ for }j=-1\\,,\n",
    "\\end{cases}\n",
    "$$\n",
    "which is consistent with the definition of `intervals` given below."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " $\\text{Code}$ - math $(\\TeX)$ **translation**"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* `start_dates`      $\\rightarrow \\{t^0_k\\}_{k=0}^K$ ,\n",
    "* `draws`    $\\rightarrow$     draws for the simulation, $Z_V$ describen in [the next section](##generate_paths),\n",
    "* `intervals` $\\rightarrow$ intervals for the simulation:\n",
    "$$\n",
    "\\textrm{intervals}[j,k]= \\begin{cases}\\textrm{intervals}[j,k]=\\text{DCC}(t^1_{j-1}, t^1_{j})\\text{ for }j>0 \\text{ (independent of } k\\text{)}\\,,\\\\\n",
    "\\textrm{intervals}[0,k]=\\text{DCC}(t^0_{k}, t^1_{0})\\text{ for }j=0\\,,\n",
    "\\end{cases}\n",
    "$$\n",
    "\n",
    "where $\\text{DCC}$ represents the day count convention, see Chapter 1 of BM, and will depend on the calendar used. For simplicity, we can think of it as $\\text{DCC}(t,t')=t'-t$ as a year fraction."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## generate_paths"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "It returns the simulation paths for the asset price. Following the notation of [Andersen, 2008], for the $i$-th simulation and the $k$-th valuation date if we denote by `paths` the output of this method we have\n",
    "$$\n",
    "\\textrm{paths}[i,j,k,l=0] = \\hat{X}_{i,k}(t^1_{j-1,k}), \\quad j\\in\\{0, \\ldots, J+1\\},\n",
    "$$ \n",
    "where \n",
    "$$\n",
    "t^1_{j-1,k}:= \\begin{cases} t^1_{j} \\qquad \\text{ for }j\\geq 0 \\quad \\text{ (independent of } k\\text{)}\\,,\\\\\n",
    "t^0_{k} \\qquad \\text{ for }j=-1\\,,\n",
    "\\end{cases}\n",
    "$$\n",
    "which is consistent with the definition of `intervals` given above."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Note that in this case, if **CHANGE**\n",
    "\n",
    "`draws = self.generate_draws(corr=corr, no_obsdates, no_valuation_dates, no_sims)` (inside `DeterministicVolDiffusionMC`)\n",
    "\n",
    "with `corr` = $I_2$, $2\\times2$ identity matrix, we have:\n",
    "\n",
    "- `draws[i,j,k,0]` is a sample of a random variable ($Z_V$) for the i-th simulation and the k-th valuation date for the j-th step (simulation date).\n",
    "- `draws[i,j,k,1]` is a sample of a random variable ($Z$) for the i-th simulation and the k-th valuation date for the j-th step (simulation date)."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# MultiAssetHeston(MultiAsset)"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## generate_paths"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "It returns the simulation paths for multiple asset prices using the MultiAssetHeston model. Following the notation of [Andersen, 2008], for the $i$-th simulation and the $k$-th valuation date if we denote by `paths` the output of this method, we have for the $l$-th asset\n",
    "$$\n",
    "\\textrm{paths}[i,j,k,l] = \\hat{X}^l_{i,k}(t^1_{j-1,k}), \\quad j\\in\\{0, \\ldots, J+1\\},\n",
    "$$ \n",
    "where \n",
    "$$\n",
    "t^1_{j-1,k}:= \\begin{cases} t^1_{j} \\qquad \\text{ for }j\\geq 0 \\quad \\text{ (independent of } k\\text{)}\\,,\\\\\n",
    "t^0_{k} \\qquad \\text{ for }j=-1\\,,\n",
    "\\end{cases}\n",
    "$$\n",
    "which is consistent with the definition of `intervals` given above.\n",
    "\n",
    "In this case, if we have `draws = self.generate_draws(corr=corr, no_obsdates, no_valuation_dates, no_sims)` (inside `DeterministicVolDiffusionMC`), with `corr` being the with `corr` = $I_{2\\times (L+1), 2\\times (L+1)}$, the identity matrix.\n",
    "\n",
    "- `draws[i,j,k,l]` is a sample of a random variable ($Z_V^l$) for the $i$-th simulation, the $k$-th valuation date, and the $l$-th asset for the $j$-th step (simulation date).\n",
    "- `draws[..., self.no_assets:]` corresponds to the vector of i.i.d. standard normal variables ($Z$) used in (A.24) of Mokone. This must be properly transformed so that we can use Andersen's approach (`Heston.generate_paths` here) for a single asset. In particular, from the aforementioned (A.24) and (9.85) of Andersen and Piterbarg, we have:\n",
    "$$\n",
    "Z^{\\text{Andersen}} = L^* D Z,\\qquad D=\\text{diag}\\left(\\frac1{\\sqrt{1-\\rho_0^2}},\\ldots,\\frac1{\\sqrt{1-\\rho_L^2}}\\right).\n",
    "$$\n",
    "\n",
    "Here, $l$ ranges from $0$ to $L$.\n"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# SABR"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "A class for simulating the SABR stochastic volatility model using the stochastic Alpha Beta Rho stochastic volatility (SABR-SV) model, which is widely used in the fi-\n",
    "nancial industry for the pricing of fixed income instruments. We will follow the notation used in [Chen et al., 2011]."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## generate_paths_vol"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Returns the variance in the SABR model following a standard geometric Brownian motion, p.18 of Chen et al. For each simulation and for each valuation date we have $\\sigma(t)$ as described in [Chen et al., 2011]. That is to say, for the $i$-th simulation and the $k$-th valuation date we have:\n",
    "\n",
    "$$\n",
    "\\textrm{paths}[i, j, k] = \\hat{\\sigma}_{i,k}(t^1_{j-1,k}), \\quad j\\in\\{0, \\ldots, J+1\\},\n",
    "$$\n",
    "where \n",
    "$$\n",
    "t^1_{j-1,k}:= \\begin{cases} t^1_{j} \\qquad \\text{ for }j\\geq 0 \\quad \\text{ (independent of } k\\text{)}\\,,\\\\\n",
    "t^0_{k} \\qquad \\text{ for }j=-1\\,,\n",
    "\\end{cases}\n",
    "$$\n",
    "which is consistent with the definition of `intervals` given below. The simulation depends on the starting date as, for instance, \n",
    "$$\n",
    "\\hat{\\sigma}_{i,k}(t^1_{0-1,k}) = \\hat{\\sigma}_{i,k}(t^0_{k}) = \\sigma(t_k^0)\\,,\n",
    "$$\n",
    "which is a common value for all simulations for that valuation date. For observable parameters, the initial condition would be obtained using market data, although here this parameter can be subject to calibration. Similarly, parameters can depend on the simulation date.\n"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Technical note"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "For the sake of educational purposes, let us give a full-detailed description of the actual implementation of this part, with a full vectorization is as follows (no loop needed). As $\\sigma$ follows a standard geometric Brownian motion with zero drift, i.e.,\n",
    "$$\n",
    "d\\sigma_t = \\alpha \\sigma_t dW_t\\,,\n",
    "$$\n",
    "let $Y := \\log(\\sigma)$, using the Itô rule,\n",
    "$$\n",
    "dY_t = -\\frac12 \\alpha^2 dt + \\alpha d W_t \\,,\n",
    "$$\n",
    "which can be easily integrated between $s$ and $t$. \n",
    "$$\n",
    "Y_t - Y_s = -\\frac12 \\alpha^2 (t-s) + \\alpha Z\\sqrt{t-s} \\,,\n",
    "$$\n",
    "with $Z\\sim\\mathcal{N}(0,1).$ Then `base[i,j,k]` is given by\n",
    "$$\n",
    "\\Delta_j\\hat{Y}^{i,k} := \\hat{Y}^{i,k}(t^1_{j})-\\hat{Y}^{i,k}(t^1_{j-1}) = -\\frac12 \\alpha_k^2 \\textrm{intervals}_{jk} + \\alpha_k \\cdot \\textrm{draws}_{ijk} \\cdot \\sqrt{\\textrm{intervals}_{jk}}\\,,\n",
    "$$\n",
    "where \n",
    "$$\n",
    "\\textrm{intervals}[j,k]= \\begin{cases}\\textrm{intervals}[j,k]=\\text{DCC}(t^1_{j-1}, t^1_{j})\\text{ for }j>0 \\text{ (independent of } k\\text{)}\\,,\\\\\n",
    "\\textrm{intervals}[0,k]=\\text{DCC}(t^0_{k}, t^1_{0})\\text{ for }j=0\\,.\n",
    "\\end{cases}\n",
    "$$\n",
    "$\\text{DCC}$ represents the day count convention, see [Brigo & Mercurio, 2006], and will depend on the calendar used. For simplicity, we can think of it as $\\text{DCC}(t,t')=t'-t$ as a year fraction. Also, \n",
    "\n",
    "- `draws[i,j,k]` is a sample of a random variable for the $i$-th simulation and the $k$-th valuation date for the $j$-th step (simulation date).\n",
    "\n",
    "Thus, a telescopic cancellation gives, by definition using `np.add.accumulate`:\n",
    "$$\n",
    "\\textrm{paths}[i,j,k]= \\begin{cases}\\textrm{paths}[i,j,k]=\\sum_{j'=0}^{j-1}\\Delta_{j'}\\hat{Y}^{i,k} = \\hat{Y}^{i,k}(t^1_{j-1})-\\hat{Y}^{i,k}(t^1_0) = \\hat{Y}^{i,k}(t^1_{j-1})-\\log(\\sigma_0^k)\n",
    "&\\text{ for }j>0 \\,,\\\\\n",
    "\\textrm{paths}[i,0,k]=0&\\text{ for }j=0\\,.\n",
    "\\end{cases}\n",
    "$$\n",
    "Finally, renaming ``paths``:\n",
    "$$\n",
    "\\hat{\\sigma}_{i,k}(t^1_{j-1})=\\textrm{paths}[i,j,k]= \\begin{cases}\\textrm{paths}[i,j,k]=\\sigma_0^k\\cdot \\exp\\left(\\hat{Y}^{i,k}(t^1_{j-1})-\\log(\\sigma_0^k)\\right) = \\exp\\left(\\hat{Y}^{i,k}(t^1_{j-1})\\right)\n",
    "&\\text{ for }j>0 \\,,\\\\\n",
    "\\textrm{paths}[i,0,k]=\\sigma_0^k&\\text{ for }j=0\\,.\n",
    "\\end{cases}\n",
    "$$\n"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " $\\text{Code}$ - math $(\\TeX)$ **translation**"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* `start_dates`      $\\rightarrow \\{t^0_k\\}_{k=0}^K$ ,\n",
    "* `draws`    $\\rightarrow$     normal draws as above,\n",
    "* `intervals` $\\rightarrow$ intervals as above."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## generate_paths"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "It returns the simulation paths for the asset price. Following the notation of [Chen et al., 2011], for the $i$-th simulation and the $k$-th valuation date if we denote by `paths` the output of this method we have\n",
    "$$\n",
    "\\textrm{paths}[i,j,k,l=0] = \\hat{S}_{i,k}(t^1_{j-1,k}), \\quad j\\in\\{0, \\ldots, J+1\\},\n",
    "$$ \n",
    "where \n",
    "$$\n",
    "t^1_{j-1,k}:= \\begin{cases} t^1_{j} \\qquad \\text{ for }j\\geq 0 \\quad \\text{ (independent of } k\\text{)}\\,,\\\\\n",
    "t^0_{k} \\qquad \\text{ for }j=-1\\,,\n",
    "\\end{cases}\n",
    "$$\n",
    "which is consistent with the definition of `intervals` given above. The simulation depends on the starting date as, for instance, \n",
    "$$\n",
    "\\hat{S}_{i,k}(t^1_{0-1,k}) = \\hat{S}_{i,k}(t^0_{k}) = S(t_k^0)\\,,\n",
    "$$\n",
    "which is a common value for all simulations for that valuation date, the initial condition that would be obtained using market data. Similarly, parameters can depend on the simulation date."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In this case, we have:\n",
    "\n",
    "- `draws[i,j,k,0]` is a sample of a normal random variable ($W_{2,1}$, p.18) for the $i$-th simulation and the $k$-th valuation date for the $j$-th step (simulation date).\n",
    "- `draws[i,j,k,1]` is a sample of a normal random variable ($W_{1}=N^{-1}(U_1)$, p.19) for the $i$-th simulation and the $k$-th valuation date for the $j$-th step (simulation date).\n",
    "- `draws[i,j,k,2]` is a sample of a normal random variable ($Z$ of (3.9)) for the $i$-th simulation and the $k$-th valuation date for the $j$-th step (simulation date).\n",
    "- `draws[i,j,k,3]` is a sample of a *uniform* random variable ($U$ of p.13) for the $i$-th simulation and the $k$-th valuation date for the $j$-th step (simulation date).\n",
    "\n",
    "\n"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " $\\text{Code}$ - math $(\\TeX)$ **translation**"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* `start_dates`      $\\rightarrow \\{t^0_k\\}_{k=0}^K$ ,\n",
    "* `step_dates`      $\\rightarrow \\{t^1_j\\}_{j=0}^J$ ,\n",
    "* `draws`    $\\rightarrow$     normal draws as above,\n",
    "* `intervals` $\\rightarrow$ intervals as above."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# References"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* [Andersen, 2008] Andersen, L. (2008). Simple and efficient simulation of the Heston stochastic volatility model.\n",
    "            Journal of Computational Finance, 11(3), 1-42.\n",
    "\n",
    "* [Brigo & Mercurio, 2006] Brigo, D., & Mercurio, F. (2006). Interest Rate Models: Theory and Practice(Chapter 1). Springer.\n",
    "\n",
    "* [Chen et al., 2011] Chen, B., Grzelak, L. A., & Oosterlee, C. W. (2011). Calibration and Monte Carlo pricing of the SABR-Hull-White model for long-maturity equity derivatives.\n",
    "The Journal of Computational Finance (79–113) Volume, 15.\n",
    "\n",
    "* [Andersen & Piterbarg, 2010] Andersen, L. and Piterbarg, V., (2010). Interest Rate Modeling.\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.16"
  },
  "vscode": {
   "interpreter": {
    "hash": "ad2bdc8ecc057115af97d19610ffacc2b4e99fae6737bb82f5d7fb13d2f2c186"
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
